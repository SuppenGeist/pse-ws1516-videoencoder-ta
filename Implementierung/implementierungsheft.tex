\documentclass[parskip=full]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage{hyperref}
\usepackage{mathptmx} 
\usepackage[scaled]{helvet}
\usepackage{graphicx}
\hypersetup{
pdftitle={Implementierungsheft},
bookmarks=true,
}

\makeatletter
\setlength{\@fptop}{0pt}
\makeatother

\usepackage{csquotes} 

{
\titlehead{\centering\includegraphics[width=10cm]{Logo.png}}
\title{\fontsize{40}{48} \selectfont \textsc{Implementierungsheft}\\
{\fontsize{18}{18} \selectfont Multimediatool zum Testen von Videoencodern}}}
\author {Johannes Werner, Noel Schuhmacher, Sascha Rapp, Simon Grafenhorst,\\
Carina Weber, Jan Benedikt Schwarz}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage
\section{EntwurfsÃ¤nderungen}
\subsection{Legende}
\textbf{Aufbau eines Eintrags:}
\begin{verbatim}
{+,-,#} {Sichtbarkeitsbereich} ...
\end{verbatim}
Grund der Aenderung.\\
\\
\textbf{Aenderungszeichen:}
\begin{itemize}
\item[] + \hspace{5mm}-->\hspace{5mm} Hinzugefuegt
\item[] - \hspace{5mm}-->\hspace{5mm} Entfernt
\item[] \# \hspace{5mm}-->\hspace{5mm} Geaendert
\end{itemize}
\textbf{Sichtbarkeitsbereiche:}
\begin{itemize}
\item public
\item public slots
\item signals
\item protected
\item private slots
\item private
\end{itemize}
\newpage
\subsection{Allgemeines}
\begin{itemize}
\item Korrigierte Rechtschreibfehler in den Klassen-/Methodennamen werden nicht dokumentiert. 
\item Allen Attributen wird ein Unterstrich zur bessern Lesbarkeit des Codes angehaengt.
\item Gui-Klassen werden folgende Methoden bei Bedarf hinzugefuegt:
\begin{verbatim}
+ (private) void createUi()
+ (private) void connectActions()
\end{verbatim}
Diese Methoden dienen allein der Lesbarkeit des Codes.

\item Aenderungen an den folgenden Methodenspezifizierern werden nicht dokumentiert:
\begin{verbatim}
const
noexcept
\end{verbatim}

\end{itemize}
\newpage
\subsection{Filterkofigurationsboxen}
\subsubsection{Basisklasse: FilterConfigurationBox}
\begin{verbatim}
+ (public) static std::unique_ptr<FilterConfigurationBox>
CreateConfigurationBox(FilterTab& filterTab, Model::Filter& filter)
\end{verbatim}
Fabrikmethode zur Erstellung einer FilterConfigurationBox fuer einen bestimmten Filter.
\begin{verbatim}
+ (public) void setFilterTab(FilterTab& filterTab)
+ (public) void setFilterIndex(std::size_t index)
+ (private) std::size_t index
+ (private) FilterTab* filterTab
\end{verbatim}
Dass der UndoCommand zum Rueckgaengig machen der Aenderung am Filter korrekt erstellt werden kann.
\begin{verbatim}
+ (public) virtaul void updateUi()
\end{verbatim}
Um der FilterConfigurationBox bescheid sagen zu koennen, dass der Filter sich ausserhalb der Box geaendert hat.
\begin{verbatim}
+ (protected) void updatePreview()
\end{verbatim}
Wird von der erbenden Klasse aufgerufen, um die Vorschau entsprechend den Aenderungen des Benutzers anzupassen.
\begin{verbatim}
+ (protected) void updateTempFilter();
\end{verbatim}
Wird von der erbenden Klasse aufgerufen, um den temporaeren Filter auf den Stand des originalen Filters zu bringen.
\begin{verbatim}
+ (private slots) applyFilter()
+ (private slots) resetFilter()
\end{verbatim}
Slots fuer die entsprechenden Buttons.
\begin{verbatim}
+ (private) static QImage& getDefaultImage()
+ (private) static std::unique_ptr<QImage> defaultImage
\end{verbatim}
Stellt das Standardbild fuer die Vorschau zur Verfuegung.
\begin{verbatim}
+ (protected) std::unique_ptr<Model::Filter> tempFilter
\end{verbatim}
Temporaeres Filterobjekt, auf welched die erbende Klasse die Aenderungen des Benutzers anwendet.
\begin{verbatim}
+ (protected) QScrollArea* filterOptionsArea
+ (private) std::unique_ptr<QImage>
+ (private) FrameView* filterPreview
+ (private) QLabel* label_filter
+ (private) QPushButton* button_apply
+ (private) QPushButton* button_reset
\end{verbatim}
Steuerung der Gui.
\subsubsection{Allgemein erbende Klassen}
\begin{verbatim}
+ (protected) void updateUi()
\end{verbatim}
Zum updaten der Gui. Wird geerebt von der Basisklasse.
\begin{verbatim}
+ (private) void createFilterOptions()
\end{verbatim}
Erstellt die Gui.
\begin{verbatim}
+ (private slots) ...
\end{verbatim}
Slots fuer die Gui-Elemente.
\begin{verbatim}
+ (private) ...
\end{verbatim}
Attribute zur Steuerung der Gui.
\newpage
\subsection{Filter}
\subsubsection{Basisklasse: Filter}
\begin{verbatim}
+ (public) static std::unique_ptr<Filter> CreateFilter(QString filtername)
\end{verbatim}
Fabrikmethode um einen Filter aufgrund dessen Name zu erstellen.
\begin{verbatim}
# (public) virtual std::string getName()=0

std::string => QString
\end{verbatim}
Bessere Kompatibilitaet mit den Qt Gui Elementen.

\begin{verbatim}
+ (public) virtual void restore(QString description)=0
+ (public) virtual QString getSaveString()=0
\end{verbatim}
Zum einfachen kopieren von Filtern, wenn die konkrete Klasse nicht bekannt ist und zum einfachen Laden und Speichern der Filter.

\subsubsection{Allgemein erbende Klassen}
\begin{verbatim}
+ (public) static const QString FILENAME
\end{verbatim}
Um Filternamen nicht 'nackt' in den Quelltext zu schreiben.
\begin{verbatim}
# (public) void std::string getName()
+ (public) void restore(QString description)
+ (public) void QString getSaveString()
\end{verbatim}
Uebernommene Aenderungen aus der Basisklasse.
\subsubsection{BlackWhiteFilter}
\begin{verbatim}
class BlackWhitefilter => class GrayscaleFilter
\end{verbatim}
Korrekte Uebersetzung ins Englische.
\subsubsection{BlendingFilter}
\begin{verbatim}
class BlendingFilter => geloescht
\end{verbatim}
Widerspruch mit der FilterPreview Funktionalitaet.
\subsubsection{BlurFilter}
\begin{verbatim}
- (public) bool getPreserveEdges()
- (public) bool setPreserveEdges()
- (private) bool preserveEdges
\end{verbatim}
Die Option hatte keinen Effekt auf das Ergebnis.

\subsubsection{BorderFilter}
\begin{verbatim}
# (public) void setColor(QRgb color)
# (public) QRgb getColor()
# (private) QRgb color

QRgb => QColor
\end{verbatim}
Komfortablerer Umgang mit QColor.

\subsubsection{GridFilter}
\begin{verbatim}
# (public) void setColor(QRgb color)
# (public) QRgb getColor()
# (private) QRgb color

QRgb => QColor
\end{verbatim}
Komfortablerer Umgang mit QColor.
\subsubsection{RectangleFilter}
\begin{verbatim}
# (public) void setColor(QRgb color)
# (public) QRgb getColor()
# (private) QRgb color

QRgb => QColor
\end{verbatim}
Komfortablerer Umgang mit QColor.
\subsubsection{ZoomFilter}
\begin{verbatim}
class ZoomFilter => geloescht
\end{verbatim}
Bug in libavfilter.

\subsection{AnalysisBoxContainerMemento}
\begin{verbatim}
# (public) std::vector<AnalysisBoxMemento> getAnalysisBoxList()

std::vector<AnalysisBoxMemento> 
=> std::vector<std::unique_ptr<AnalysisBoxMemento>>&

- (private) std::vector<AnalysisBoxMemento*> mementoList

std::vector<AnalysisBoxMemento*>
=>std::vector<std::unique_ptr<AnalysisBoxMemento>>
\end{verbatim}
Unnoetiges kopieren vermeiden.
\begin{verbatim}
- (public) void setAnalysisBoxList(std::vector<AnalysisBoxMemento> analysisBoxList)
+ (public) void addMemento(std::unique_ptr<AnalysisBoxMemento> memento)
\end{verbatim}
Komfortablere Schnittstelle.

\subsection{AnalysisBoxMemento}
\begin{verbatim}
# (public) QString getVideoPath()
# (public) void setVideoPath(QString videoPath)
# (private) QString videoPath

videoPath => \{P,p\}ath

# (public) Model::Video* getMacroVideo()
# (public) void setMacroVideo(Model::Video* macroVideo)
# (private) Model::Video* macroVideo

\{M,m\}acro => \{M,m\}acro\{B,b\}lockVideo

# (public) Model::Graph getPsnr()
# (public) void setPsnr(Model::Graph psnr)
# (private) Model::Graph psnr

\{P,p\}snr => \{P,p\}snrGraph

# (public) Model::Graph getBitrate()
# (public) void setBitrate(Model::Graph Bitrate)
# (private) Model::Graph bitrate

\{B,p=b\}snr => \{B,b\}snrGraph

\end{verbatim}
Sauberere Namensgebung.

\begin{verbatim}
# (public) Model::Graph getPsnr()
# (public) void setPsnr(Model::Graph psnr)
# (private) Model::Graph psnr
# (public) Model::Graph getBitrate()
# (public) void setBitrate(Model::Graph Bitrate)
# (private) Model::Graph bitrate

Model::Graph => Model::Graph*
\end{verbatim}
Unnoetiges kopieren vermeiden.

\begin{verbatim}
+ (public) void setEncoder(QString encoder)
+ (public) QString getEncoder()
+ (public) void setAverageBitrate(QString bitrate)
+ (public) QString getAverageBitrate()
+ (public) void setFilename(QString filename)
+ (public) QString getFilename()
+ (public) void setFilesize(QString size)
+ (public) QString getFilesize()
+ (public) void setRedHistogram(Model::GraphVideo* video)
+ (public) Model::GraphVideo* getRedHistogram()
+ (public) void setGreenHistogram(Model::GraphVideo* video)
+ (public) Model::GraphVideo* getGreenHistogram()
+ (public) void setBlueHistogram(Model::GraphVideo* video)
+ (public) Model::GraphVideo* getBlueHistogram()
+ (private) QString encoder
+ (private) QString avergaeBitrate
+ (private) QString filename
+ (private) QString filesize
+ (private) Model::GraphVideo* redHistogram
+ (private) Model::GraphVideo* greenHistogram
+ (private) Model::GraphVideo* blueHistogram
\end{verbatim}
Vergessene Attribute, die auch gespeichert werden muessen.

\subsection{AnalysisTabMemento}
\begin{verbatim}
# (public) int getCurrentVideoPosition()
# (public) void setCurrentVideoPosition(int currentVideoPosition)
# (private) int currentVideoPosition

\{C,c\}urrentVideo => Player
\end{verbatim}
Sauberere Namensgebung.
\begin{verbatim}
- (public) int getCurrentlyShownAnalysisVideo()
- (public) void setCurrentlyShownAnalysisVideo(int currentVideo)
- (private) int currentlyShownAnalysisVideo
- (public) float getCurrentSpeed()
- (public) void setCurrentSpeed(float currentSpeed)
- (private) currentSpeed
\end{verbatim}
Nicht realisierbar bzw. nicht mehr von noeten.
\begin{verbatim}
# (public) AnalysisBoxContainerMemento getAnalysisBoxContainerMemento()

AnalysisBoxContainerMemento => AnalysisBoxContainerMemento*

# (public) void setAnalysisBoxContainerMemento(AnalysisBoxContainerMemento memento)

AnalysisBoxContainerMemento => std::unique_ptr<AnalysisBoxContainerMemento>

+ (private) std::unique_ptr<AnalysisBoxContainerMemento> analysisboxMemento
\end{verbatim}
Unnoetiges Kopieren vermeiden.
\begin{verbatim}
+ (public) void setRawVideo(Model::YuvVideo* video)
+ (public) void setRawVideo(std::unique_ptr<Model::YuvVideo> video)
+ (public) std::unique_ptr<Model::YuvVideo> releaseVideo()
+ (public) Model::YuvVideo* getRawVideo()
+ (public) GUI::AnalysisGraph getAnalysisGraph()
+ (public) void setAnalysisGraph(GUI::AnalysisGraph graph)
+ (public) GUI::AnalysisVideo getAnalysisVideo()
+ (public) void setAnalysisVideo(GUI::AnalysisVideo video)
+ (private) Model::YuvVideo* rawVideo
+ (private) std::unique_ptr<Model::YuvVideo> ownedVideo
+ (private) GUI::AnalysisGraph graph
+ (private) GUI::AnalysisVideo video
\end{verbatim}
Vergessene Attribute, die auch gespeichert werden muessen.
\subsection{FilterTabMemento}
\begin{verbatim}
# (public) bool getWasApplied()
# (public) void setWasApplied(bool wasApplied)
# (private) bool wasApplied

WasApplied => IsFilteredVideoShown

# (public) int getDisplayedFrame()
# (public) void setDisplayedFrame(int displayedFrame)
# (private) int displayedFrame

DisplayedFrame => CurrentFrame

\end{verbatim}
Sauberere Namensgebung.
\begin{verbatim}
# (public) Model::FilterList getFilterList()
# (public) void setFilterList(Model::FilterList list)
# (private) Model::FilterList  filterList

Model::FilterList => std::unique_ptr<Model::FilterList>
\end{verbatim}
Abstrakte Klassen lassen sich nicht kopieren.
\begin{verbatim}
- (public) std::string getLoadedFile()
- (public) void setLoadedFile(std::string loadedFile)
- (private) std::string loadedFile
\end{verbatim}
Wurden ersetzt durch bessere Methoden.
\begin{verbatim}
+ (public) void setRawVideo(Model::YuvVideo* rawVideo)
+ (public) void setRawVideo(std::unique_ptr<Model::YuvVideo> video)
+ (public) std::unique_ptr<Model::YuvVideo> releaseVideo()
+ (public) Model::YuvVideo* getRawVideo()
+ (public) void setIsPreviewShown(bool isShown)
+ (public) bool isPreviewShow()
+ (public) void setCurrentFrame(int currentFrame)
+ (public) int getCurrentFrame()
+ (public) void setCurrentlySelectedFilter(int filter)
+ (public) int getCurrentlySelectedFilter()
+ (private) Model::YuvVideo* rawVideo
+ (private) std::unique_ptr<Model::YuvVideo> ownedRawVideo
+ (private) bool isPreviewShown
+ (private) int currentFrame
+ (private) int currentlySelectedFilter
\end{verbatim}
Vergessene Attribute, die auch gespeichert werden muessen.
\subsection{MainWindowMemento}
\begin{verbatim}
# (public) AnalysisTabMemento getAnalysisTabMemento()
# (public) FilterTabMemento getFilterTabMemento()

AnalysisTabMemento => AnalysisTabMemento*
FilterTabMemento => FilterTabMemento*

# (public) void setAnalysisTabMemento(AnalysisTabMemento memento)
# (public) void setFilterTabMemento(FilterTabMemento memento)

AnalysisTabMemento => std::unique_ptr<AnalysisTabMemento>
FilterTabMemento => std::unique_ptr<FilterTabMemento>

# (private) AnalysisTabMemento* analysisTab
# (private) FilterTabMemento* filterTab

AnalysisTabMemento* => std::unique_ptr<AnalysisTabMemento>
FilterTabMemento* => std::unique_ptr<FilterTabMemento>

\end{verbatim}
Unnoetiges Kopieren vermeiden.
\subsection{AddFilter}
\begin{verbatim}
# (public) AddFilter(GUI::FilterTab* filterTab,Model::Filter filter)

(...) => (GUI::FilterTab& filterTab, QString filternam)

- (private) Model::Filter filter
+ (private) QString filtername
+ (private) std::unique_ptr<Memento::FilterTabMemento> memento
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind. 

\subsection{AddVideo}
\begin{verbatim}
# (public) AddVideo(GUI::AnalysisBoxContainer* container,Model::EncodedVideo video)

Model::EncodedVideo => QString

- (private) Model::EncodedVideo video
+ (private) QString filename
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind. 
\subsection{ChangeFilter}
\begin{verbatim}
class ChangeFilter => erstellt
\end{verbatim}
Hat sich angeboten.
\subsection{FilterReset}
\begin{verbatim}
# (public) FilterReset(GUI::FilterTab* tab,Model::FilterList list)

(...) => (GUI::FilterTab& filterTab)

# (private) Model::FilterList filterList

Model::FilterList => std::unique_ptr<Model::FilterList>

+ (private) std::unique_ptr<Memento::FilterTabMemento> memento
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind. 
\subsection{ApplyFilter}
\begin{verbatim}
class ApplyFilter => geloescht
\end{verbatim}
War unnoetig.
\subsection{LoadAnalysisVideo}
\begin{verbatim}
# (public) LoadAnalysisVideo(GUI::AnalysisTab* tab, 
Memento::AnalysisTabMemento memento, Model::YuvVideo video)

(...) => (GUI::AnalysisTab* tab, std::unique_ptr<YuvVideo> video)

# (private) Model::YuvVideo* video

Model::YuvVideo* => std::unique_ptr<YuvVideo>

+ (private) std::unique_ptr<Memento::AnalysisTabMemento> memento
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind. 
\subsection{LoadFilterConfig}
\begin{verbatim}
# (public) LoadFilterConfig(GUI::FilterTab* tab,
Model::FilterList old,Model::FilterList new)

(...) => (GUI::FilterTab& tab,std::unique_ptr<Model::FilterList> newList)

# (private) Model::Filter:ist* newList

Model::FilterList* => std::unique_ptr<Model::FilterList>

- (private) Model::FilterList* oldList
+ (private) std::unique_ptr<Memento::FilterTabMemento> memento
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind.
\subsection{LoadFilterVideo}
\begin{verbatim}
# (public) LoadFilterVideo(GUI::FilterTab* tab,Model::YuvVideo video,
Memento::FilterTabMemento memento)

(...) => (GUI::FilterTab& tab,std::unique_ptr<Model::YuvVideo> video,
std::unique_ptr<Memento::FilterTabMemento> memento)

# (private) Memento::FilterTabMemento* memento
# (private) Model::YuvVideo* video

Memento::FilterTabMemento* => std::unique_ptr<FilterTabMemento>
Model::YuvVideo* => std::unique_ptr<Model::YuvVideo>
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind.
\subsection{MoveFilterDown}
\begin{verbatim}
# (public) MoveFilterDown(GUI::FilterTab* tab, int oldIndex, int newIndex)

(...) => (GUI::FilterTab& tab, int index)

- (private) int newIndex
- (private) int oldIndex
+ (private) int index
+ (private) std::unique_ptr<Memento::FilterTabMemento>
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind.
\subsection{MoveFilterUp}
Genau diesselben Aenderungen wie in der Klasse 'MoveFilterDown'.
\subsection{RemoveFilter}
\begin{verbatim}
# (public) RemoveFilter(GUI::FilterTab* tab,Model::Filter filter, int index)

(...) => (GUI::FilterTab& tab, int index)

# (private) Model::Filter* filter

Model::Filter* => std::unique_ptr<Model::filter>

+ (private) std::unique_ptr<Memento::FilterTabMemento> memento
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind.
\subsection{RemoveVideo}
\begin{verbatim}
# (public) RemoveVideo(GUI::AnalysisBoxContainer* container, Model::EncodedVideo video)

(...) => (GUI::AnalysisBoxContainer* container, GUI::AnalysisBox* box)

- (private) Model::EncodedVideo* video
+ (private) int index
+ (private) std::unique_ptr<Memento::AnalysisBoxMemento> memento
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind.
\subsection{WriteComment}
\begin{verbatim}
# (public) WriteComment()

() => (GUI::AnalysisBoxContainer* container, int index, QString oldComment,
QString newComment)

+ (private) GUI::AnalysisBoxContainer* container
+ (private) int index
+ (private) QString oldComment
+ (private) QString newComment
\end{verbatim}
Es lies sich im Entwurf nur schwer einschaetzen, was fuer Attribute noetig fuer das Rueckgaengig machen sind.
\subsection{AVVideo}
\begin{verbatim}
std::unique_ptr<AVFrame> => AVFrame*
int index => std::size_t index
\end{verbatim}
Aenderungen aufgrund der Implementierung von AVFrame und std::vector.
\begin{verbatim}
# (public) AVVideo(int fps, int width, int height)

(...) => (int fps)
\end{verbatim}
Die Dimension wird jetzt vom ersten Frame, dass in das Video gesteckt wird, bestimmt.

\begin{verbatim}
- (public) void insertFrames(int index, std::vector<std::unique_ptr<AVFrame>>& frames)
\end{verbatim}
Wird nicht benoetigt.

\begin{verbatim}
+ (public) void setFps(int fps)
\end{verbatim}
Um beim Konvertieren die Fps korrekt zu setzen.
\begin{verbatim}
+ (public) void appendFrame(AVFrame* frame)
\end{verbatim}
Komfortablere Schnittstelle.
\begin{verbatim}
+ (public) bool isComplete()
+ (public) void setIsComplete(bool isComplete)
+ (private) bool isComplete
\end{verbatim}
Um feststellen zu koennen, ob das Video vollstaendig ist, oder noch auf Frames gewartet werden muss.
\subsection{EncodedVideo}
\begin{verbatim}
- (public) int getFileSize()
- (public) getNumberOfColors()
- (public) void setBitrate (Model::Graph graph)
- (public) void setPsnr (Model::Graph graph)
- (public) void setRedHistogramm (Model::Graph graph)
- (public) void setGreenHistogramm (Model::Graph graph)
- (public) void setBlueHistogramm (Model::Graph graph)
- (public) void setMacroblockVideo (GUI::Video video)
- (public) void setRgbDiffVideo (GUI::Video video)
- (private) int fileSize
- (private) int numberOfColors
- (private) QString codec
\end{verbatim}
Wird nicht benoetigt.
\begin{verbatim}
# (public) Model::Graph& getRedHistogram()
# (public) Model::Graph& getGreenHistogram()
# (public) Model::Graph& getBlueHistogram()
# (private) Model::Graph* redHisto
# (private) Model::Graph* greenHisto
# (private) Model::Graph* blueHisto

Model::Graph& => Model::GraphVideo&
Model::Graph* => std::unique_ptr<Model::GraphVideo>
\end{verbatim}
Ein Histogramm von einem Video ist kein einzelner Graph.
\begin{verbatim}
# (public) Model::Graph& getPsnr()

Model::Graph& => Model::Graph*
() => (Model::Video* reference)

# (public) Model::Video& getRgbDiffVideo(Model::Video* reference)

Model::Video& => Model::Video*
\end{verbatim}
Wenn die reference null ist und nicht berechnet werden kann, muss ein nullptr zurueck gegeben werden.

\begin{verbatim}
+ (public) int getAverageBitrate()
\end{verbatim}
Zusaetzliches Attribut zum Anzeigen.
\begin{verbatim}
# (private) Model::Video* video
# (private) Model::AVVideo* avVideo
# (private) Model::Video* rgbDiffVideo
# (private) Model::Video* macroBlockVideo
# (private) Model::Graph* bitrate
# (private) Model::Graph* psnr

Model::Video* => std::unique_ptr<Model::Video>
Model::AVVideo* => std::unique_ptr<Model::AVVideo>
Model::Graph* => std::unique_ptr<Model::Graph>

- (private) Model::Video* displayVideo
\end{verbatim}
Pointer werden in smartpointer gepackt.
\begin{verbatim}
+ (private) std::unique_ptr<Utility::VideoLoader> loader
+ (private) 	std::unique_ptr<Utility::BitrateCalculator> bitrateCalculator
+ (private) std::unique_ptr<Utility::RGBHistogramCalculator> rgbHistoCalculator
+ (private) std::unique_ptr<Utility::PsnrCalculator> psnrCalculator
+ (private) std::unique_ptr<Utility::RGBDifferenceCalculator> rgbDiffCalculator
+ (private) std::unique_ptr<Utility::VideoConverter> macroblockConverter
+ (private) std::unique_ptr<Utility::VideoConverter> videoConverter
+ (private) std::unique_ptr<Utility::VideoLoader> macroblockLoader
+ (private) void calculateHistograms()
\end{verbatim}
Attribute zur Berrechnung der einzelnen Videos und Graphen.
\subsection{FilterList}
\begin{verbatim}
- (public) Filter* getFilterByName(std::string name)
- (public) int getIndex(std::string name)
- (public) void addFilter(std::string name, int index)
- (public) void removeFilter(std::string name)
\end{verbatim}
Werden nicht benoetigt
\begin{verbatim}
+ (public) std::unique_ptr<Filter> removeFilter(std::size_t index)
+ (public) Filter* appendFilter(QString name)
+ (public) void insertFilter(std::unique_ptr<Filter> filter, std::size_t index)
+ (public) std::size_t getSize()

# (public) void moveFilter(int oldPos, int newPos)

int => std::size_t
\end{verbatim}
Bessere Schnittstelle
\begin{verbatim}
# (private) std::vector<Filter*> filters

Filter => std::unique_ptr<Filter>
\end{verbatim}
Packe pointer in smartpointer
\subsection{Graph}
\begin{verbatim}
- (public) void cut(int x)
\end{verbatim}
Wird nicht benoetigt.
\begin{verbatim}
# (public) void addValue(int x, double y)
# (public) double getValue(int x)
# (public) removeValue(int x)
# (public) int getLength()

addValue => setValue
getLength => getSize
int => std::size_t

+ (public) getBiggestValue()
\end{verbatim}
Bessere Schnittstelle.
\subsection{GraphVideo}
\begin{verbatim}
class GraphVideo => erstellt
\end{verbatim}
Um RgbHistogramms fuer Videos anzeigen zu koennen.
\subsection{Project}
\begin{verbatim}
# (public) void setMemento(Memento::MainWindowMemento memento)
# (private) Memento::MainWindowMemento* memento

Memento::MainWindoeMemento => std::unique_ptr<Memento::MainWindowMemento>
Memento::MainWindoeMemento* => std::unique_ptr<Memento::MainWindowMemento>
\end{verbatim}
Verhindere unnoetiges Kopieren.
\begin{verbatim}
+ (public) void setName(QString name)
\end{verbatim}
Um den Namen des Projectes setzen zu koenne, dass beim Start des Programms als leeres Projekt erstellt wird.
\subsection{Video}
\begin{verbatim}
# (public) Video(int fps, int width, int height)

(...) => (int fps)
\end{verbatim}
Die Dimension wird jetzt vom ersten Frame, dass in das Video gesteckt wird, bestimmt.

\begin{verbatim}
- (public) void insertFrames(int index, std::vector<std::unique_ptr<QImage>>& frames)
\end{verbatim}
Wird nicht benoetigt.

\begin{verbatim}
# (public) QImage* getFrame(int index)
# (public) void insertFrame(std::unique_ptr<QImage> frame, int index)
# (public) void removeFrame(int index)
# (public) int getNumberOfFrames()

int => std::size_t
\end{verbatim}
an vector anpassen

\begin{verbatim}
+ (public) void setFps(int fps)
+ (public) bool appendFrame(std::unique_ptr<QImage> frame)
\end{verbatim}
Schnittstelle erweitern

\begin{verbatim}
+ (public) void setIsComplete(bool isComplete)
+ (public) bool isComplete()
+ (private) bool isComplete
\end{verbatim}
Um feststellen zu koennen, ob das Video vollstaendig ist, oder noch auf Frames gewartet werden muss.
\subsection{YuvVideo}
\begin{verbatim}
# (public) YuvVideo(QString path,Utility::PixelSheme type, int width, int height, int fps)

(...) => (QString path, Utility::YuvType type, Utility::Compression compression, int width, int height, int fps)

# (private) Utility::PixelSheme yuvType

Utility::PixelSheme => Utility::YuvType
\end{verbatim}
Compression wurde im Design vergessen.

\begin{verbatim}
+ (public) int getWidth()
+ (public) int getHeight()
+ (public) int getFps()
\end{verbatim}
Getter wurden im Design vergessen.

\begin{verbatim}
+ (public) GraphVideo& getRedHistogram()
+ (public) GraphVideo& getGreenHistogram()
+ (public) GraphVideo& getBlueHistogram()
+ (private) std::unique_ptr<GraphVideo> redHisto
+ (private) std::unique_ptr<GraphVideo> greenHisto
+ (private) std::unique_ptr<GraphVideo> blueHisto
+ (private) std::unique_ptr<Utility::RGBHistogramCalculator> histogramCalculator
+ (private) void calculateHistograms();
\end{verbatim}
Zum berrechnen von histogrammen

\begin{verbatim}
- (public) Model::AVVideo& getAvVideo()
- (private) std::unique_ptr<Model::AVVideo> avVideo
\end{verbatim}
Wird nicht benoetigt.

\begin{verbatim}
+ (private) std::unique_ptr<Utility::YuvFileReader> fileReader
+ (private) void loadVideo()
\end{verbatim}
Zum laden des Videos.
\subsection{BitrateCalculator}
\begin{verbatim}
- (public) Model::Graph calculate()
+ (public) void calculate(Model::Graph* target)

+ (private) std::thread calculator
+ (private) bool isRunning
+ (private) Model::Graph* target
+ (private) void calculateP()
\end{verbatim}
Ermoegliche threads.
\subsection{FilterApplier}
\begin{verbatim}
# (public) FilterApplier(Model::FilterList& list)

(...) => (Model::FilterList& list, int width, int height, int pixelFormat)
\end{verbatim}
Mehr informatioon benoetigt.
\begin{verbatim}
# (public) void applyToVideo(Model::AVVideo& target, Model::AVVideo& source)

Model::AVVideo => Model::Video

+ (public) void applyToVideo(Model::Video& target, Model::AVVideo& source)

- (private) AVFrame applyToFrame(AVFrame& source)
+ (public) AVFrame* applyToFrame(AVFrame& source)
\end{verbatim}
Bessere Schnittstelle
\begin{verbatim}
+ (signals) void applyComplete(bool successful)
\end{verbatim}
Um die stausbar updaten zu koennen.
\begin{verbatim}
+ (private) int width
+ (private) int height
+ (private) int pixelFormat
+ (private) AVFilterGraph* filterGraph
+ (private) AVFilterContext* buffersinkContext
+ (private) AVFilterContext* buffersourceContext
+ (private) std::string filterDescription
+ (private) std::thread applier
+ (private) Model::Video* source
+ (private) Model::AVVideo* source1
+ (private) Model::Video* target
+ (private) bool isRunning

+ (private) void createFilterString()
+ (private) void applyToVideoP()
+ (private) void applyToAVVideoP()
\end{verbatim}
Fuer multithreading und berechnung
\subsection{FilterConfigurationLoader}
\begin{verbatim}
# (public) Model::FilterList getConfiguratin()

Model::FilterList => std::unique_ptr<Model::FilterList>
\end{verbatim}
Kopieren vermeiden
\subsection{FilterConfigurationSaver}
\begin{verbatim}
+ (private) Model::FilterList* filterList
\end{verbatim}
Speichern der Liste vom Konstruktor
\subsection{ProjectReader}
\begin{verbatim}
# (public) Model::Project readProject()

Model::Project => std::unique_ptr<Model::Project>
\end{verbatim}
Kopieren vermeiden.
\begin{verbatim}
- (private) QFile file
- (private) QTextStream dataStream

- (private) void parseFilterTab(Memento::FilterTabMemento* memento,QString line)
- (private) void parseAnalysisTab(Memento::AnalysisTabMemento* memento,QString line)
\end{verbatim}
\subsection{ProjectWriter}
\begin{verbatim}
# (public) ProjectWriter(Model::Project project)

Model::Project => Model::Project*
\end{verbatim}
Kopieren verhindern

\begin{verbatim}
- (public) void saveResults()
\end{verbatim}
Wurde in eigene Klasse ausgelagert
\begin{verbatim}
+ (private) Model::Project* project
+ (private) std::unique_ptr<QFile> file
+ (private) QTextStream dataStream
\end{verbatim}
\subsection{PsnrCalculator}
\begin{verbatim}
# (public) PsnrCalculator(Model::AVVideo& reference, Model::AVVideo& video)

Model::AVVideo => Model::Video
\end{verbatim}
Einfacher zu benutzen
\begin{verbatim}
+ (private) double calculateMeanSquareError(QImage* frame1, QImage* frame2);
\end{verbatim}
Wird zum berrechen benoetigt
\begin{verbatim}
+ (private) std::thread calculator
+ (private) Model::Graph* target
+ (private) bool isRunning

+ (private) void calculateP()
\end{verbatim}
Fuer threading.
\subsection{ResultSaver}
\begin{verbatim}
class ResultSaver => erstellen
\end{verbatim}
Auslagerung vom result saven aus dem project
\subsection{RgbDifferenceCalculator}
\begin{verbatim}
# (public) void calculateVideo(Model::Video& target)

Model::Video& => Model::Video*
\end{verbatim}
\begin{verbatim}
+ (private) Model::Video* target
+ (private) std::thread calculator
+ (private) bool isRunning

+ (private) void calculateP()
\end{verbatim}
Threading.
\subsection{RGBHistogramCalculator}
\begin{verbatim}
# (public) void calculate()

() => (Model::GraphVideo* targetRed,Model::GraphVideo* targetGreen, Model::GraphVideo* targetBlue)

+ (private) std::thread calculator
+ (private) bool isRunning
\end{verbatim}
Threading.
\begin{verbatim}
# (private) Model::Graph red
# (private) Model::Graph green
# (private) Model::Graph blue

Model::Graph => Model::GraphVideo*
\end{verbatim}
Histogramm fuer ein Video ist auch ein Video.
\subsection{VideoConverter}
\begin{verbatim}
+ (public) VideoConverter(Model::AVVideo* video)
+ (public) VideoConverter(Model::Video* video)

- (public) static std::unique_ptr<Model::AVVideo> convertVideoToAVVideo(Model::Video& video)
- (public) static std::unique_ptr<Model::Video> convertAVVideoToVideo(Model::AVVideo& video)

+ (public) void convertAVVideoToVideo(Model::Video* target)
+ (public) void convertVideoToAVVideo(Model::AVVideo* target)
+ (private) Model::Video* video
+ (private) Model::Video* videoTarget
+ (private) Model::AVVideo* avvideo
+ (private) Model::AVVideo* avvideoTarget

+ (private) std::thread converter
+ (private) bool isRunning

+ (private) void convertVideoP()
+ (private) void convertAVVideoP()
\end{verbatim}
Threading
\begin{verbatim}
# (public) std::unique_ptr<AVFrame> convertImageToAVFrame(Qimage& image)

std::unique_ptr<AVFrame> => AVFrame*

# (public) static std::unique_ptr<QImage> convertAVFrameToImage(AVFrame& frame, int width, int height)

(...) => (AVFrame& frame)
\end{verbatim}
Andere werden nicht benoetigt.
\begin{verbatim}
+ (public) static std::unique_ptr<QImage> convertGraphToImage(Model::Graph* graph,int width,int height, GUI::GraphCalculator* calculator=0);

+ (public) static std::unique_ptr<Model::Video> convertGraphVideoToVideo(Model::GraphVideo* video,int width,int height,GUI::GraphCalculator* calculator);

\end{verbatim}
Konvertiere Graphen zu Images.
\subsection{VideoLoader}
\begin{verbatim}
# (public) VideoLoader(QString path)

(...) => (QString path, AVDictionary* dict)

+ (private) 	AVDictionary *dict_;
\end{verbatim}
Macroblocks.
\begin{verbatim}
- (public) std::unique_ptr<Model::AVVideo> loadVideo()
+ (public) void loadVideo(Model::AVVideo *target)

+ (private) std::thread loader
+ (private) bool isRunning

+ (private) void loadP()
\end{verbatim}
Threading.
\begin{verbatim}
+ (public) QString getCodec()
+ (public) int getAverageBitrate()

+ (private) QString codec
+ (private) int averageBitrate
\end{verbatim}
Attribute des videos
\subsection{VideoSaver}
\begin{verbatim}
class VideoSaver => erstellen
\end{verbatim}
Um encodierte Videos speichern zu koenne.
\subsection{YuvFileReaders}
\subsubsection{Basisklasse: YuvFileReader}
\begin{verbatim}
# (public) YuvFileReader(QString filename, int width, int height)

(...) => (QString filename, int width, int height, int framesize)
\end{verbatim}
Um den buffer alloziieren zu koennen.

\begin{verbatim}
- (public) virtual std::unique_ptr<Model::Video> read()
+ (public) void read(Model::Video* target)

+ (public)	void stopReading();
+ (public)	bool isRunning();
	
	
+ (private) bool isRunning
+ (private) std::thread reader

+ (private) void readP()
\end{verbatim}
Threading
\begin{verbatim}
- (protected) std::unique_ptr<QByteArray> binaryData
- (protected) std::unique_ptr<Model::Video> video

+ (protected) virtual std::unique_ptr<QImage> parseNextFrame()

+ (protected) unsigned char* binaryData
+ (protected) QDataStream dataStream
+ (protected) QFile file
+ (protected) Model::Video* video
+ (protected) int frameSize
+ (protected) bool* complete
\end{verbatim}
\subsubsection{Allgemein erbende Klassen}
\begin{verbatim}
- (public) std::unique_ptr<Model::Video> read()

# (private) std::unique_ptr<QImage> parseNextFrame()

private => protected
\end{verbatim}
\subsection{YuvFileSavers}
\subsubsection{Basisklasse: YuvFileSaver}
\begin{verbatim}
+ (signals) void saveComplete(bool successful,QString filename,int width,int height)
\end{verbatim}
Signalisierung des Endes
\begin{verbatim}
+ (public) static int RgbToY(QRgb pixel)
+ (public) static int RgbToU(QRgb pixel)
+ (public) static int RgbToV(QRgb pixel)
\end{verbatim}
Funktionen zue konvertierung.
\subsubsection{Allgemein erbende Klassen}
\begin{verbatim}
+ (private) std::thread safer
+ (private) bool isRunning

+ (private) void saveP()
\end{verbatim}
Threading.
\subsubsection{Yuv420FileSaver}
\begin{verbatim}
- (private) void saveFrame(int index)
\end{verbatim}
Nicht gebraucht.
\subsubsection{Yuv422FileSaver}
\begin{verbatim}
+ (private) Compression compression
\end{verbatim}
Vergessen im design.
\subsubsection{Yuv444FileSaver}
\begin{verbatim}
+ (private) Compression compression
\end{verbatim}
Vergessen im design.
\subsection{AnalysisBox}
\begin{verbatim}
# (public) Memento::AnalysisBoxMemento getMemento()

Memento::AnalysisBoxMemento => std::unique_ptr<AnalysisBoxMemento>

# (public) void restore(Memento::AnalysisBoxMemento memento)

Memento::AnalysisBoxMemento => Memento::AnanlysisBoxMemento*
\end{verbatim}
Kopieren verhindern

\begin{verbatim}
- (public) void setRawVideo(Model::Video* video
- (private) Model::Video rawVideo*

+ (public) void setParentContainer(AnalysisBoxContainer* container)
+ (private) AnalysisBoxContainer* parentContainer
\end{verbatim}
Hole das rohvideo ueber den parent.

\begin{verbatim}
- (public) void setAnalysisVideo(Model::EncodedVideo video)
+ (public) void setFile(QString filename)

# (private) Model::EncodedVideo* origVideo

Model::EncodedVideo* => std::unique_ptr<Model::EncodedVideo>
\end{verbatim}
Kapsle das Video in der box
\begin{verbatim}
# (public) void setControlPanel(GlobalControlPanel* panel)
# (private) GlobalControlPanel* controlPanel

GlobalControlPanel* => std::shared_ptr<GlobalControlPanel>
\end{verbatim}
Destructor dependencies

\begin{verbatim}
- (public) void showRGBDifferenceVideo()
- (public) void showMacroBlockVideo()

+ (public) void showGraph(AnalysisGraph graph)
+ (public) void showAnalysisVideo(AnalysisVideo video)
+ (public) void showAttributes()
\end{verbatim}
Saubrere Schnittstelle
\begin{verbatim}
+ (public) QString getPath()
+ (public) QPlainTextEdit* getCommentBox()
+ (private) QString currentComment
\end{verbatim}
Fuer UndoCommands
\begin{verbatim}
+ (public) void lockUi()
+ (public) void unlockUi()
\end{verbatim}
Ui locken fuer das save results
\begin{verbatim}
+ (private slots) void updateLabels()
+ (private) QTimer timer_updateLabels
\end{verbatim}
Um labels so lange zu updaten bis alle information vorhanden sind
\begin{verbatim}
- (private) int currentlyPlayedVideo
+ (private) GraphWidget* graphWidget
+ (private) QLabel* label_title
+ (private) QLabel* label_filename
+ (private) QLabel* label_filesize
+ (private) QLabel* label_codec
+ (private) QLabel* label_averageBitrate
+ (private) std::unique_ptr<GraphPlayer> graphPlayer
+ (private) std::unique_ptr<GraphCalculator> calculator

# (private) VideoPlayer* plainVideoPlayer
# (private) VideoPlayer* analysisVideoPLayer

VideoPlayer* => std::unique_ptr<VideoPlayer>
\end{verbatim}
Zusaetzlich fue dri gui benoetigt
\begin{verbatim}
- (private) GraphWidget psnrGraph
- (private) GraphWidget bitrateGraph
- (private) GraphWidget redHistogramm
- (private) GraphWidget blueHistogramm
- (private) GraphWidget greenHistogramm
\end{verbatim}
Wird in EncodedVideo gespeichert
\subsection{AnalysisBoxContainer}
\begin{verbatim}
# (public) Memento::AnalysisBoxContainerMemento getMemento()

Memento::AnalysisBoxContainerMemento => std::unique_ptr<Memento::AnalysisBoxContainerMemento>

# (public) void restore(Memento::AnalysisBoxContainerMemento memento)

Memento::AnalysisBoxContainerMemento => Memento::AnalysisBoxContainerMemento*
\end{verbatim}
Kopieren verhindern.
\begin{verbatim}
+ (public) void setParentTab(AnalysisTab* parent)
+ (public) AnalysisTab* getParentTab()
+ (private) AnalysisTab* parent
\end{verbatim}
Parent sichtbar fuer analysisboxen
\begin{verbatim}
- (public) void addVideo(QString path)
- (public) void addVideo(Model::EncodedVideo video)
+ (public) AnalysisBox* appendBox(AnalysisBox* box)

# (public) void removeBox(AnalysisBox& box)

AnalysisBox& => AnalysisBox*
void => int

- (public) void setRawVideo(Model::Video* video)
- (private) Model::Video* video

- (public) void showMacroBlockVideo()
- (public) void showRGBDifferenceVideo()

+ (public) void showGraph(AnalysisGraph graph)
+ (public) void showAnalysisVideo(AnalysisVideo video)
+ (public) void showAttributes()
+ (public) AnalysisGraph getShownGraph()
+ (public) AnalysisVideo getShownVideo()
+ (private) AnalysisGraph currentGraph
+ (private) AnalysisVideo currentVideo

+ (public) void clear()
+ (public) AnalysisBox* insertBox(AnalysisBox* box, std::size_t index)
+ (public) AnalysisBox* getAnalysisBox(std:size_t index)
+ (public) int getIndex(AnalysisBox* box)
+ (public) std::size_t getNumberOfBoxes()
\end{verbatim}
Bessres schnittstelle
\begin{verbatim}
+ (private) QVBoxLayout v_boxes
+ (private) QSpacerItem* spacer
+ (private) QPushButton* button_addVideo

+ (private slots) void addVideo()
+ (private) void updateUi()
\end{verbatim}
Zusaetlich fue dir gui.
\begin{verbatim}
# (public) void setControlPanel(GloablControlPanel* panel)
# (private) GlobalControlPanel* panel

GloablControlPanel* => std::shared_ptr<GlobalControlPanel>
\end{verbatim}
Destructor dependencies
\begin{verbatim}
+ (public) void lockUi()
+ (public) void unlockUi()
\end{verbatim}
Fuer das results saven
\subsection{AnalysisGraph}
\begin{verbatim}
enum class AnalysisGraph => erstellt
\end{verbatim}
\subsection{AnalysisVideo}
\begin{verbatim}
enum class AnalysisVideo => erstellt
\end{verbatim}
\subsection{AnalysisTab}
\begin{verbatim}
# (public) Memento::AnalysisTabMemento getMemento()

Memento::AnalysisTabMemento => std::unique_ptr<Memento::AnalysisTabMemento>

# (public) void restore(Memento::AnalysisTabMemento memento)

Memento::AnalysisTabMemento => Memento::AnalysisTabMemento*
\end{verbatim}
Kopieren verhindern.
\begin{verbatim}
# (public) void setRawVideo(Model::YuvVideo video)

Model::YuvVideo => Model::YuvVideo*

+ (public) Model::YuvVideo* getRawVideo()
\end{verbatim}
Rawvideo wird im undocommand gespeichert
\begin{verbatim}
+ (public) bool isRawVideoLoaded()
\end{verbatim}
Fuert den container, ob er en video adden darf
\begin{verbatim}
+ (public) void setParentWindow(MainWindow* window)
+ (public) MainWindow* getParentWindow()
+ (private) MainWindow* parentWindow
\end{verbatim}
Fuer statusbar
\begin{verbatim}
+ (protected) void resizeEvent(QResizeEvent * event)

+ (private slots) void showBitrate()
+ (private slots) void showRedHistogram()
+ (private slots) void showBlueHistogram()
+ (private slots) void showGreenHistogram()
+ (private slots) void showPsnr()
+ (private slots) void showAttributes()
+ (private slots) void analysisVideoChanged(int index)
+ (private slots) void updateLabels()
+ (private slots) void resultSavingFinished()
- (private slots) void addVideo()

+ (private) QPushButton* button_attributes
+ (private) 	QPushButton* button_redHistogram
+ (private) 	QPushButton* button_blueHistogram
+ (private) QPushButton* button_greenHistogram
+ (private) QPushButton* button_bitrate
+ (private) QPushButton* button_psnr
+ (private) QVBoxLayout* v_rawVideo
+ (private) GraphWidget* graphWidget
+ (private) QString stylesheet_buttons
+ (private) QString stylesheet_buttonsSelected
+ (private) QLabel* label_filesize
+ (private) QLabel* label_resolution
+ (private) QLabel* label_framesize
+ (private) QPushButton* button_loadnewvideo
- (private) QPushButton button_addVideo
+ (private) std::unique_ptr<ForwardPlayer> forwardPlayer
+ (private) std::unique_ptr<GraphPlayer> graphPlayer
+ (private) std::unique_ptr<GraphCalculator> calculator
+ (private) FrameView* rawVideoView
+ (private) std::unique_ptr<Utility::ResultSaver> resultsSaver
+ (private) QTimer timer_labelUpdater
	
# (private) VideoPLayer* player

VideoPlayer* => std::unique_ptr<VideoPlayer>
\end{verbatim}
Zusaetzlich fue die gui
\subsection{ControlPanel}
\begin{verbatim}
# (public) void addVideoPlayer(Player& player)

PLayer& => Player*
\end{verbatim}
\begin{verbatim}
# (private) std::vector<VideoPayer*>

VideoPlayer* => Player*
\end{verbatim}
Dass auch graphplayers rein koennen
\subsection{FilterContainerTab}
\begin{verbatim}
# (public) void addFilter(Model::Filter filter)

Model::Filter => QString
\end{verbatim}
komfortabler
\begin{verbatim}
- (public) void unchecl(QString filtername)
\end{verbatim}
Nicht merh benoetigt
\begin{verbatim}
+ (private) container
+ (private) filterContainer
\end{verbatim}
Zusaetzlich fuer die gui.
\subsection{FilterTab}
\begin{verbatim}
# (public) Memento::FilterTabMemento getMemento()

FilterTabMemento => std::unique_ptr<FilterTabMemento>

# (public) void restor(Memento::FilterTabMemento memento)

FilterTabMemento => FilterTabMemento*
\end{verbatim}
Kopiren vermeiden.
\begin{verbatim}
+ (public) static constexpr int MAX_PREVIEW_COUNT
\end{verbatim}
Magic numbers vermeiden.

\begin{verbatim}
# (public) void insertFilter(Model::Filter filter, int index)

Model::Filter =-> std::unique_ptr<Filter>
int => std::size_t

# (public) void removeFilter(std::string filter)

void => std::unique_ptr<Model::Filter>
std::string => std::size_t

# (public) void moveFilter(int pos1, int pos2)

int -> std::size_t

+ (public) void changeFilter(int index, QString newState)
+ (public) Model::Filter* appendFilter(QString filtername)

# (public) void setFilterList(Model::FilterList list)

Model::FilterList => std::unique_ptr<Model::FilerList>

+ (public) Model::FilterList* getFilterList()
\end{verbatim}
Besseres schnittstelle fuer filter
\begin{verbatim}
# (public) void setRawVideo(Model::YuvVideo video)

Model::YuvVideo => Model::YuvVideo*
\end{verbatim}
Video wird in undocommand gespeichert
\begin{verbatim}
+ (public) void updateFilterPreview()
+ (public) void showFilteredVideo()
\end{verbatim}
Mehr Kontroll ueber den tab.
\begin{verbatim}
+ (public) void setMainWindow(MainWindow* window)
+ (public) MainWindow* getMainWindow()
+ (private) MainWindow* mainWindow

+ (private slots) void notifyOnSaveComplete(bool successful,QString filename,int width,int height)
+ (private slots) void notifyOnApplyComplete(bool successful)
\end{verbatim}
Fuer statusbar
\begin{verbatim}
- (private) QLabel* filterOptions
- (private) QFrame* filterContainer
+ (private) QVBoxLayout* v_player

# (private) VideoPlayer* player

VideoPlayer* => std::unique_ptr<VideoPlayer>

+ (private) QHBoxLayout* h_filterOptions
+ (private) QSpacerItem* spacer_filterOptions
+ (private) FilterConfigurationBox* currentFilterOptionsBox
	
# (private) Model::FilterList filterList
	
Model::FilterList => std::unique_ptr<Model::FilterList>
	
+ (private) std::unique_ptr<Model::AVVideo> originalPreviewFrames
+ (private) std::unique_ptr<Model::Video> filteredPreviewFrames
+ (private) std::unique_ptr<Utility::FilterApplier> previewCalculator
+ (private) std::unique_ptr<Utility::FilterApplier> filterApplier
+ (private) std::unique_ptr<Model::Video> filteredVideo
+ (private) bool isFilteredVideoShown
+ (private) std::unique_ptr<Utility::YuvFileSaver> safer
- (private) st::vector<FilterContainerTab> filterContainerTab

+ (private) void createButtons()
+ (private) void createListView()
+ (private) void createVideoPlayer()
+ (private) void createFilterTabs()
+ (private) void initPlayer()
+ (private) void initFilterList()
+ (private) void calculatePreviewFrames()
\end{verbatim}
Zuseatzlih fue gui
\subsection{FilterView}
\begin{verbatim}
# (public) void setFilter(Model::Filter filter)

Model::Filter => QString
\end{verbatim}
Komfortabler
\begin{verbatim}
+ (private) static std::unique_ptr<QImage> defaultImage

- (private) void checkBoxStateChanged()
- (private) QCheckBox* checkbox
- (private) QLabel* preview

# (private) Model::Filter* filter
Model::Filter* => std::unique_ptr<Model::Filter>

+ (private) QPushButton* button_addFilter
+ (private slots) void buttonPressed()
+ (private) std::unique_ptr<QImage> filterImage
\end{verbatim}
Fue gui
\subsection{ForwardPlayer}
\begin{verbatim}
+ (public) void setMasterVideoPlayer(Player* player)
+ (private) Player* player
- (private) ControlPanel controlPanel
\end{verbatim}
Um alles Methoden implementieren zu koennen.
\begin{verbatim}
+ (public) std::size_t getNumberOfFrames()
\end{verbatim}
\subsection{FrameView}
\begin{verbatim}
# (protected) void repaintEvent(QPaintEvent* event)
repaintEvent => paintEvent
\end{verbatim}
Falscher name.
\begin{verbatim}
+ (private) QPixmap drawedImage
\end{verbatim}
Konvertierun vermeiden.
\subsection{GlobalControlPanel}
\begin{verbatim}
+ (public) int getPosition()
\end{verbatim}
War noetig
\subsection{GraphCalculator}
\begin{verbatim}
class GraphCalculator => erstellt
\end{verbatim}
Um das Berrechnen vom anzeigen zu trennen.
\subsection{GraphPlayer}
\begin{verbatim}
class GraphPlayer => erstellt
\end{verbatim}
um Rgb histogramme abspielen zu koenne.
\subsection{GraphWidget}
\begin{verbatim}
# (public) void drawGraph(Model::Graph g, bool filled)
(...) => (Model::Graph* graph)

+ (public) Model::Graph* getGraph()
\end{verbatim}
Bessere schnittstelle
\begin{verbatim}
- (public) void setLineColor(QRgb color)
- (public) void setFillColor(QRgb color)
- (private) QRgb lineColor
- (private) QRgb fillColor

+ (public) void setGraphCalculator(GraphCalculator* calculator)
+ (private) GraphCalculator* calculator
\end{verbatim}
Berrechnen wird ausgelagert.
\begin{verbatim}
+ (public) void buildScene()
+ (protected) void resizeEvent(QResizeEvent* event)
+ (private) QTimer updater
+ (private) QGraphicsScene scene
+ (private slots) void updateView()
\end{verbatim}
Zum zeichnen.
\subsection{MainWindow}
\begin{verbatim}
# (public) Memento::MainWindowMemento getMemento()
Memento::MainWindowMemento => std::unique_ptr<Memento::MainWindowMemento>

# (public) void restore(Memento::MainWindowMemento memento)
Memento::MainWindowMemento => Memento::MainWindowMemento*
\end{verbatim}
Kopieren vermeiden.
\begin{verbatim}
- (public) Model::Project& getProject()
\end{verbatim}
nicht benoetigt.
\begin{verbatim}
# (private) Model::Project* loadedProject
Model::Project* => std::unique_ptr<Model::Project>
\end{verbatim}
Packs in nen msartpointer
\begin{verbatim}
+ (public) QStatusBar* getStatusBar()
\end{verbatim}
Fuer statusbar
\begin{verbatim}
- (private) void createMenuBar()

- (private) QMenuBar* menubar_project
- (private) QMenuBar* menubar_edit

+ (private) FilterTab* filterTab
+ (private) AnalysisTab* analysisTab
+ (private) Ui::MainWindow* ui
\end{verbatim}
Fuer gui
\subsection{Player}
\begin{verbatim}
# (public) virtual void setPosition(int position)
# (public) virtual int getPosition()

int => std::size_t
\end{verbatim}
\begin{verbatim}
+ (public) std::size_t getNumberOfFrames()
\end{verbatim}
\subsection{PlayerControlPanel}
\begin{verbatim}
# (public) void updateUi()
public => public slots

+ (private) QTimer updater
\end{verbatim}
Um die gui dem player anzupassen.
\subsection{PreviewControlPanel}
\begin{verbatim}
# (public) void updateUi()
public => public slots

+ (private) QTimer updater
- (private) void updateLabel()
\end{verbatim}
Um die guid em video anzupassen.
\subsection{Timer}
\begin{verbatim}
# (public) void addPlayer(VideoPlayer& player)
# (public) void removePlayer(VideoPlayer& player)

VideoPlayer& => Player&

+ (private) std::vector<Player*> players
\end{verbatim}
Um auch graphplayers reinpacken zu koenne.
\subsection{VideoPlayer}
\begin{verbatim}
# (public) void setVideo(Video& video)

(...) => (Video* video,bool updateTimer)
\end{verbatim}
Um videos zu clearn oder um hinzuzufuegen ohne den timer zu stoppen.
\begin{verbatim}
# (public) void setPosition(int position)
# (public) int getPosition()
# (private) int position

int => std::size_t
\end{verbatim}
geerebt.
\begin{verbatim}
+ (public) std::size_t getNumberOfFrames()
\end{verbatim}
\begin{verbatim}
+ (private) QTimer viewUpdater
+ (private slots) void updateViews()

# (private) Timer timer
Timer => std::shared_ptr<Timer>
\end{verbatim}
\subsection{YuvFileOpenDialog}
\begin{verbatim}
+ (public) static constexpr int MAX_SAVED_ENTRIES
+ (public) static const QString SAVE_FILENAME
\end{verbatim}
Magische zahlen vermeiden.
\begin{verbatim}
+ (public) int getFps()
+ (public) int getWidth()
+ (public) int getHeight()
+ (public) Utility::Compression getCompression()
+ (public) Utility::YuvType getPixelSheme()

+ (private) int fps
+ (private) int width
+ (private) int height
+ (private) Utility::Compression compression
+ (private) Utility::YuvType type

+ (private) void askAttributes()
+ (private) bool parseAttributes()
\end{verbatim}
Speichere auch attribute der yuv datei.
\begin{verbatim}
- (public) void show()
- (public) bool wasSuccessfull()
\end{verbatim}
Wird von QDialg uebernommen.
\begin{verbatim}
+ (private slots) void chooseFile()
+ (private slots) void selectionChanged(const QItemSelection& selection)
+ (private slots) void hasFinished(int result)

+ (private) QLineEdit* lineEdit_selectedFile
\end{verbatim}
Fuer gui
\begin{verbatim}
- (private) static void loadRecentlyUsed()
- (private) static QListViewModel model_recentlyUsed

+ (private) static QStringListModel* getListModel()
+ (private) static void saveListModel(QString selectedFile, QString attributes)
+ (private) static QStringListModel* model_recentlyUsed
\end{verbatim}
Fui recently used dateien
\subsection{YuvInfoDialog}
\begin{verbatim}
# (public) PixelSheme getPixelSheme()
PixelSheme => Utility::YuvType
\end{verbatim}
klasse war doppelt.
\begin{verbatim}
- (public) void show()
- (public) bool wasSuccessfull()
\end{verbatim}
Wird von QDialg uebernommen.
\begin{verbatim}
+ (private) QStringList pixelShemeList
+ (private) QStringList compressionList
\end{verbatim}
Fuer gui
\end{document}
